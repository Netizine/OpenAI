<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Projects\Netizine.OpenAI\src\Netizine.OpenAI\Infrastructure\AsyncUtils.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
namespace OpenAI.Infrastructure
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    internal static class AsyncUtils
    {
        /// &lt;summary&gt;
        /// Converts an async-enumerable sequence to an enumerable sequence.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;TSource&quot;&gt;The type of the elements in the source sequence.&lt;/typeparam&gt;
        /// &lt;param name=&quot;source&quot;&gt;An async-enumerable sequence to convert to an enumerable sequence.&lt;/param&gt;
        /// &lt;returns&gt;The enumerable sequence containing the elements in the async-enumerable sequence.&lt;/returns&gt;
        /// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;&lt;paramref name=&quot;source&quot;/&gt; is null.&lt;/exception&gt;
        /// &lt;remarks&gt;
        /// This code is largely borrowed from the System.Linq.Async project (see
        /// https://github.com/dotnet/reactive/blob/7ad606b3dcd4bb2c6ae9622f8a59db7f8f52aa85/Ix.NET/Source/System.Linq.Async/System/Linq/Operators/ToEnumerable.cs).
        /// The reason we&#39;re not using System.Linq.Async directly is that it can cause issues with
        /// some versions of EF Core.
        /// &lt;/remarks&gt;
        public static IEnumerable&lt;TSource&gt; ToEnumerable&lt;TSource&gt;(IAsyncEnumerable&lt;TSource&gt; source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            var e = source.GetAsyncEnumerator();

            try
            {
                while (true)
                {
                    if (!Wait(e.MoveNextAsync()))
                    {
                        break;
                    }

                    yield return e.Current;
                }
            }
            finally
            {
                Wait(e.DisposeAsync());
            }
        }

        private static void Wait(ValueTask task)
        {
            var awaiter = task.GetAwaiter();

            if (!awaiter.IsCompleted)
            {
                task.AsTask().ConfigureAwait(false).GetAwaiter().GetResult();
                return;
            }

            awaiter.GetResult();
        }

        private static T Wait&lt;T&gt;(ValueTask&lt;T&gt; task)
        {
            var awaiter = task.GetAwaiter();

            return !awaiter.IsCompleted ? task.AsTask().ConfigureAwait(false).GetAwaiter().GetResult() : awaiter.GetResult();
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[24,13,24,32,0],[26,17,26,65,0],[29,13,29,49,0],[33,17,33,29,0],[35,21,35,50,0],[40,21,40,44,0],[42,13,42,14,0],[45,17,45,40,0],[46,13,46,14,0],[47,9,47,10,0],[51,13,51,45,0],[53,13,53,38,0],[55,17,55,78,0],[56,17,56,24,0],[59,13,59,33,0],[60,9,60,10,0],[64,13,64,45,0],[66,13,66,126,0]]);
    </script>
  </body>
</html>