<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Projects\Netizine.OpenAI\src\Netizine.OpenAI\Infrastructure\JsonConverters\UnixDateTimeConverter.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// ReSharper disable once CheckNamespace
namespace OpenAI.Infrastructure
{
    using System;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    /// &lt;summary&gt;
    /// Converts a &lt;see cref=&quot;DateTime&quot;/&gt; to and from Unix epoch time.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// This is a somewhat simplified version of the converter with the same name that was added in
    /// Newtonsoft.Json 11.0. Once we bump the minimum version of Newtonsoft.Json to 11.0, we can
    /// start using the provided converter and get rid of this class.
    /// &lt;/remarks&gt;
    public class UnixDateTimeConverter : DateTimeConverterBase
    {
        internal static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

        /// &lt;summary&gt;
        /// Writes the JSON representation of the object.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;writer&quot;&gt;The &lt;see cref=&quot;JsonWriter&quot;/&gt; to write to.&lt;/param&gt;
        /// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
        /// &lt;param name=&quot;serializer&quot;&gt;The calling serializer.&lt;/param&gt;
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            long seconds;

            if (value is DateTime dateTime)
            {
                seconds = (long)(dateTime.ToUniversalTime() - UnixEpoch).TotalSeconds;
            }
            else
            {
                throw new JsonSerializationException(&quot;Expected date object value.&quot;);
            }

            if (seconds &lt; 0)
            {
                throw new JsonSerializationException(&quot;Cannot convert date value that is before Unix epoch of 00:00:00 UTC on 1 January 1970.&quot;);
            }

            writer.WriteValue(seconds);
        }

        /// &lt;summary&gt;
        /// Reads the JSON representation of the object.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;reader&quot;&gt;The &lt;see cref=&quot;JsonReader&quot;/&gt; to read from.&lt;/param&gt;
        /// &lt;param name=&quot;objectType&quot;&gt;Type of the object.&lt;/param&gt;
        /// &lt;param name=&quot;existingValue&quot;&gt;The existing property value of the JSON that is being converted.&lt;/param&gt;
        /// &lt;param name=&quot;serializer&quot;&gt;The calling serializer.&lt;/param&gt;
        /// &lt;returns&gt;The object value.&lt;/returns&gt;
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            bool nullable = IsNullable(objectType);
            if (reader.TokenType == JsonToken.Null)
            {
                if (!nullable)
                {
                    throw new JsonSerializationException($&quot;Cannot convert null value to {objectType}.&quot;);
                }

                return null;
            }

            long seconds;

            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    seconds = (long)reader.Value!;
                    break;
                case JsonToken.String:
                    {
                        if (!long.TryParse((string)reader.Value!, out seconds))
                        {
                            throw new JsonSerializationException($&quot;Cannot convert invalid value to {objectType}.&quot;);
                        }

                        break;
                    }

                default:
                    throw new JsonSerializationException(
                        $&quot;Unexpected token parsing date. Expected Integer or String, got {reader.TokenType}.&quot;);
            }

            if (seconds &gt;= 0)
            {
                return UnixEpoch.AddSeconds(seconds);
            }

            throw new JsonSerializationException(
                $&quot;Cannot convert value that is before Unix epoch of 00:00:00 UTC on 1 January 1970 to {objectType}.&quot;);
        }

        private static bool IsNullable(Type t)
        {
            if (t == null)
            {
                throw new ArgumentNullException(nameof(t));
            }

            if (t.IsValueType)
            {
                return t.IsGenericType &amp;&amp; t.GetGenericTypeDefinition() == typeof(Nullable&lt;&gt;);
            }

            return true;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[18,9,18,107,1],[30,13,30,44,0],[32,17,32,87,0],[36,17,36,85,0],[39,13,39,29,0],[41,17,41,144,0],[44,13,44,40,0],[45,9,45,10,0],[57,13,57,52,1],[58,13,58,52,1],[60,17,60,31,0],[62,21,62,105,0],[65,17,65,29,0],[70,13,70,38,1],[73,21,73,51,1],[74,21,74,27,1],[77,25,77,80,0],[79,29,79,116,0],[86,21,87,112,0],[90,13,90,30,1],[92,17,92,54,1],[95,13,96,119,0],[101,13,101,27,1],[103,17,103,60,0],[106,13,106,31,1],[108,17,108,94,1],[111,13,111,25,0]]);
    </script>
  </body>
</html>