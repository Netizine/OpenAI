<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Projects\Netizine.OpenAI\src\Netizine.OpenAI\Infrastructure\Public\SystemNetHttpClient.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// ReSharper disable once CheckNamespace
namespace OpenAI
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Net.Http.Headers;
    using System.Threading;
    using System.Threading.Tasks;
    using OpenAI.Infrastructure;

    /// &lt;summary&gt;
    /// Standard client to make requests to OpenAI&#39;s API, using
    /// &lt;see cref=&quot;System.Net.Http.HttpClient&quot;/&gt; to send HTTP requests.
    /// It can automatically retry failed requests when it&#39;s safe to do so.
    /// &lt;/summary&gt;
    public class SystemNetHttpClient : IHttpClient
    {
        /// &lt;summary&gt;Default maximum number of retries made by the client.&lt;/summary&gt;
        public static readonly int DefaultMaxNumberRetries = 2;

        private const string OpenAINetTargetFramework =
#if NET7_0
            &quot;net7.0&quot;
#elif NET6_0
            &quot;net6.0&quot;
#elif NETSTANDARD2_0
            &quot;netstandard2.0&quot;
#elif NET462
            &quot;net462&quot;
#else
            &quot;unknown&quot;
#endif
        ;

        private static readonly Lazy&lt;System.Net.Http.HttpClient&gt; LazyDefaultHttpClient
            = new Lazy&lt;System.Net.Http.HttpClient&gt;(BuildDefaultSystemNetHttpClient);

        private readonly System.Net.Http.HttpClient httpClient;

        private readonly object randLock = new object();

        private readonly Random rand = new Random();

        private readonly string userAgentString;

        static SystemNetHttpClient()
        {
            // Enable support for TLS 1.2, as OpenAI&#39;s API requires it. This should only be
            // necessary for .NET Framework 4.5 as more recent runtimes should have TLS 1.2 enabled
            // by default, but it can be disabled in some environments.
            ServicePointManager.SecurityProtocol |= SecurityProtocolType.Tls12;
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;SystemNetHttpClient&quot;/&gt; class.
        /// &lt;/summary&gt;
        public SystemNetHttpClient()
        {
            this.httpClient = LazyDefaultHttpClient.Value;
            this.MaxNetworkRetries = DefaultMaxNumberRetries;
            this.userAgentString = BuildOpenAIClientUserAgentString();
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;SystemNetHttpClient&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;maxNetworkRetries&quot;&gt;
        /// The maximum number of times the client will retry requests that fail due to an
        /// intermittent problem.
        /// &lt;/param&gt;
        public SystemNetHttpClient(int maxNetworkRetries)
        {
            this.httpClient = LazyDefaultHttpClient.Value;
            this.MaxNetworkRetries = maxNetworkRetries;
            this.userAgentString = BuildOpenAIClientUserAgentString();
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;SystemNetHttpClient&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;httpClient&quot;&gt;
        /// The &lt;see cref=&quot;System.Net.Http.HttpClient&quot;/&gt; client to use. If &lt;c&gt;null&lt;/c&gt;, an HTTP
        /// client will be created with default parameters.
        /// &lt;/param&gt;
        public SystemNetHttpClient(System.Net.Http.HttpClient httpClient)
        {
            this.httpClient = httpClient ?? LazyDefaultHttpClient.Value;
            this.MaxNetworkRetries = DefaultMaxNumberRetries;
            this.userAgentString = BuildOpenAIClientUserAgentString();
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;SystemNetHttpClient&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;httpClient&quot;&gt;
        /// The &lt;see cref=&quot;System.Net.Http.HttpClient&quot;/&gt; client to use. If &lt;c&gt;null&lt;/c&gt;, an HTTP
        /// client will be created with default parameters.
        /// &lt;/param&gt;
        /// &lt;param name=&quot;maxNetworkRetries&quot;&gt;
        /// The maximum number of times the client will retry requests that fail due to an
        /// intermittent problem.
        /// &lt;/param&gt;
        public SystemNetHttpClient(
            System.Net.Http.HttpClient httpClient,
            int maxNetworkRetries)
        {
            this.httpClient = httpClient ?? LazyDefaultHttpClient.Value;
            this.MaxNetworkRetries = maxNetworkRetries;
            this.userAgentString = BuildOpenAIClientUserAgentString();
        }

        /// &lt;summary&gt;Default timespan before the request times out.&lt;/summary&gt;
        public static TimeSpan DefaultHttpTimeout =&gt; TimeSpan.FromSeconds(80);

        /// &lt;summary&gt;
        /// Maximum sleep time between tries to send HTTP requests after network failure.
        /// &lt;/summary&gt;
        public static TimeSpan MaxNetworkRetriesDelay =&gt; TimeSpan.FromSeconds(5);

        /// &lt;summary&gt;
        /// Minimum sleep time between tries to send HTTP requests after network failure.
        /// &lt;/summary&gt;
        public static TimeSpan MinNetworkRetriesDelay =&gt; TimeSpan.FromMilliseconds(500);

        /// &lt;summary&gt;
        /// Gets how many network retries were configured for this client.
        /// &lt;/summary&gt;
        public int MaxNetworkRetries { get; }

        /// &lt;summary&gt;
        /// Gets or sets a value indicating whether the client should sleep between automatic
        /// request retries.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;This is an internal property meant to be used in tests only.&lt;/remarks&gt;
        internal bool NetworkRetriesSleep { get; set; } = true;

        private static string BuildOpenAIClientUserAgentString()
        {
            var values = new Dictionary&lt;string, object&gt;
            {
                { &quot;bindings_version&quot;, OpenAIConfiguration.OpenAIClientVersion },
                { &quot;lang&quot;, &quot;.NET&quot; },
                { &quot;publisher&quot;, &quot;OpenAI&quot; },
                { &quot;target_framework&quot;, OpenAINetTargetFramework },
            };

            // The following values are in try/catch blocks on the off chance that the
            // RuntimeInformation methods fail in an unexpected way. This should ~never happen, but
            // if it does it should not prevent users from sending requests.
            try
            {
                values.Add(&quot;lang_version&quot;, RuntimeInformation.GetRuntimeVersion());
            }
            catch (Exception)
            {
                values.Add(&quot;lang_version&quot;, &quot;(unknown)&quot;);
            }

            try
            {
                values.Add(&quot;os_version&quot;, RuntimeInformation.GetOSVersion());
            }
            catch (Exception)
            {
                values.Add(&quot;os_version&quot;, &quot;(unknown)&quot;);
            }

            return JsonUtils.SerializeObject(values);
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;System.Net.Http.HttpClient&quot;/&gt; class
        /// with default parameters.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;The new instance of the &lt;see cref=&quot;System.Net.Http.HttpClient&quot;/&gt; class.&lt;/returns&gt;
        public static System.Net.Http.HttpClient BuildDefaultSystemNetHttpClient()
        {
            // We set the User-Agent headers in each request
            // message rather than through the client&#39;s `DefaultRequestHeaders` because we
            // want these headers to be present even when a custom HTTP client is used.
            return new System.Net.Http.HttpClient
            {
                Timeout = DefaultHttpTimeout,
            };
        }

        /// &lt;summary&gt;
        /// Make a HTTP request as an asynchronous operation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;request&quot;&gt;The parameters of the request to send.&lt;/param&gt;
        /// &lt;returns&gt;A Task&amp;lt;OpenAIResponse&amp;gt; representing the asynchronous operation.&lt;/returns&gt;
        public Task&lt;OpenAIResponse&gt; MakeRequestAsync(
            OpenAIRequest request)
        {
            return this.MakeRequestAsync(request, default);
        }

        /// &lt;summary&gt;
        /// Make a HTTP request as an asynchronous operation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;request&quot;&gt;The parameters of the request to send.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The cancellation token to cancel operation.&lt;/param&gt;
        /// &lt;returns&gt;A Task&amp;lt;OpenAIResponse&amp;gt; representing the asynchronous operation.&lt;/returns&gt;
        public async Task&lt;OpenAIResponse&gt; MakeRequestAsync(
            OpenAIRequest request,
            CancellationToken cancellationToken)
        {
            var (response, retries) = await this.SendHttpRequest(request, cancellationToken).ConfigureAwait(false);

            var reader = new StreamReader(
                await response.Content.ReadAsStreamAsync().ConfigureAwait(false));

            return new OpenAIResponse(
                response.StatusCode,
                response.Headers,
                await reader.ReadToEndAsync().ConfigureAwait(false))
            {
                NumRetries = retries,
            };
        }

        private async Task&lt;(HttpResponseMessage responseMessage, int retries)&gt; SendHttpRequest(
            OpenAIRequest request,
            CancellationToken cancellationToken)
        {
            TimeSpan duration;
            Exception requestException;
            HttpResponseMessage response = null;
            int retry = 0;

            while (true)
            {
                requestException = null;

                var httpRequest = this.BuildRequestMessage(request);

                var stopwatch = Stopwatch.StartNew();

                try
                {
                    response = await this.httpClient.SendAsync(httpRequest, cancellationToken)
                        .ConfigureAwait(false);
                }
                catch (HttpRequestException exception)
                {
                    requestException = exception;
                }
                catch (OperationCanceledException exception)
                    when (!cancellationToken.IsCancellationRequested)
                {
                    requestException = exception;
                }

                stopwatch.Stop();

                duration = stopwatch.Elapsed;

                if (!this.ShouldRetry(
                    retry,
                    requestException != null,
                    response?.StatusCode,
                    response?.Headers))
                {
                    break;
                }

                retry += 1;
                await Task.Delay(this.SleepTime(retry), cancellationToken).ConfigureAwait(false);
            }

            if (requestException != null)
            {
                throw requestException;
            }

            Console.WriteLine(&quot;Execution Time: &quot; + duration.ToString(&quot;c&quot;));
            return (response, retry);
        }

        private bool ShouldRetry(
            int numRetries,
            bool error,
            HttpStatusCode? statusCode,
            HttpHeaders headers)
        {
            // Do not retry if we are out of retries.
            if (numRetries &gt;= this.MaxNetworkRetries)
            {
                return false;
            }

            // Retry on connection error.
            if (error)
            {
                return true;
            }

            // The API may ask us not to retry (eg; if doing so would be a no-op)
            // or advise us to retry (eg; in cases of lock timeouts); we defer to that.
            if (headers != null &amp;&amp; headers.Contains(&quot;Should-Retry&quot;))
            {
                var value = headers.GetValues(&quot;Should-Retry&quot;).First();

                return value switch
                {
                    &quot;true&quot; =&gt; true,
                    &quot;false&quot; =&gt; false,
                    _ =&gt; false,
                };
            }

            // Retry on conflict errors.
            if (statusCode == HttpStatusCode.Conflict)
            {
                return true;
            }

            // Retry on 500, 503, and other internal errors.
            //
            // Note that we expect the Should-Retry header to be false
            // in most cases when a 500 is returned.
            return statusCode.HasValue &amp;&amp; ((int)statusCode.Value &gt;= 500);
        }

        private System.Net.Http.HttpRequestMessage BuildRequestMessage(OpenAIRequest request)
        {
            var requestMessage = new System.Net.Http.HttpRequestMessage(request.Method, request.Uri);

            // Standard headers
            requestMessage.Headers.TryAddWithoutValidation(&quot;User-Agent&quot;, this.userAgentString);
            requestMessage.Headers.Authorization = request.AuthorizationHeader;

            // Custom headers
            foreach (var header in request.OpenAIHeaders)
            {
                requestMessage.Headers.Add(header.Key, header.Value);
            }

            // Request body
            requestMessage.Content = request.Content;

            return requestMessage;
        }

        private TimeSpan SleepTime(int numRetries)
        {
            // We disable sleeping in some cases for tests.
            if (!this.NetworkRetriesSleep)
            {
                return TimeSpan.Zero;
            }

            // Apply exponential backoff with MinNetworkRetriesDelay on the number of numRetries
            // so far as inputs.
            var delay = TimeSpan.FromTicks((long)(MinNetworkRetriesDelay.Ticks
                * Math.Pow(2, numRetries - 1)));

            // Do not allow the number to exceed MaxNetworkRetriesDelay
            if (delay &gt; MaxNetworkRetriesDelay)
            {
                delay = MaxNetworkRetriesDelay;
            }

            // Apply some jitter by randomizing the value in the range of 75%-100%.
            double jitter;
            lock (this.randLock)
            {
                jitter = (3.0 + this.rand.NextDouble()) / 4.0;
            }

            delay = TimeSpan.FromTicks((long)(delay.Ticks * jitter));

            // But never sleep less than the base sleep seconds.
            if (delay &lt; MinNetworkRetriesDelay)
            {
                delay = MinNetworkRetriesDelay;
            }

            return delay;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[24,9,24,64,1],[40,9,41,85,1],[45,9,45,57,1],[45,9,45,57,1],[45,9,45,57,1],[45,9,45,57,0],[47,9,47,53,1],[47,9,47,53,1],[47,9,47,53,1],[47,9,47,53,0],[56,13,56,80,1],[57,9,57,10,1],[62,9,62,37,0],[64,13,64,59,0],[65,13,65,62,0],[66,13,66,71,0],[67,9,67,10,0],[76,9,76,58,1],[78,13,78,59,1],[79,13,79,56,1],[80,13,80,71,1],[81,9,81,10,1],[90,9,90,74,1],[92,13,92,73,1],[93,13,93,62,1],[94,13,94,71,1],[95,9,95,10,1],[108,9,110,35,1],[112,13,112,73,1],[113,13,113,56,1],[114,13,114,71,1],[115,9,115,10,1],[118,54,118,78,1],[123,58,123,81,0],[128,58,128,88,0],[133,40,133,44,1],[140,45,140,49,1],[140,50,140,54,1],[140,59,140,63,1],[140,59,140,63,0],[140,59,140,63,1],[140,59,140,63,1],[144,13,150,15,1],[157,17,157,84,1],[158,13,158,14,1],[159,13,159,30,0],[161,17,161,57,0],[162,13,162,14,0],[166,17,166,77,1],[167,13,167,14,1],[168,13,168,30,0],[170,17,170,55,0],[171,13,171,14,0],[173,13,173,54,1],[186,13,189,15,1],[200,13,200,60,1],[213,13,213,116,1],[215,13,216,83,1],[218,13,224,15,1],[225,9,225,10,1],[233,13,233,49,1],[234,13,234,27,1],[236,13,236,25,1],[238,17,238,41,1],[240,17,240,69,1],[242,17,242,54,1],[246,21,247,48,1],[248,17,248,18,1],[249,17,249,55,1],[251,21,251,50,1],[252,17,252,18,1],[254,21,254,70,1],[256,21,256,50,1],[257,17,257,18,1],[259,17,259,34,1],[261,17,261,46,1],[263,17,267,40,1],[272,17,272,28,1],[273,17,273,98,1],[274,13,274,14,1],[276,13,276,42,1],[278,17,278,40,1],[281,13,281,76,1],[282,13,282,38,1],[283,9,283,10,1],[292,13,292,54,1],[294,17,294,30,1],[298,13,298,23,1],[300,17,300,29,1],[305,13,305,69,1],[307,17,307,71,0],[309,17,311,31,0],[311,31,311,35,0],[311,35,312,32,0],[312,32,312,37,0],[312,37,313,26,0],[313,26,313,31,0],[313,31,314,19,0],[318,13,318,55,1],[320,17,320,29,1],[327,13,327,74,1],[332,13,332,102,1],[335,13,335,96,1],[336,13,336,80,1],[339,22,339,32,0],[339,33,339,35,1],[339,36,339,57,1],[341,17,341,70,0],[345,13,345,54,1],[347,13,347,35,1],[353,13,353,43,1],[355,17,355,38,1],[360,13,361,49,0],[364,13,364,48,0],[366,17,366,48,0],[371,13,371,33,0],[373,17,373,63,0],[374,13,374,14,0],[376,13,376,70,0],[379,13,379,48,0],[381,17,381,48,0],[384,13,384,26,0]]);
    </script>
  </body>
</html>