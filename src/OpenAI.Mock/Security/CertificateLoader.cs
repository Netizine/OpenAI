using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.OpenSsl;

namespace OpenAI.Mock.Security;

internal class CertificateLoader
{
    // see https://github.com/aspnet/Common/blob/61320f4ecc1a7b60e76ca8fe05cd86c98778f92c/shared/Microsoft.AspNetCore.Certificates.Generation.Sources/CertificateManager.cs#L19-L20
    // This is the unique OID for the developer cert generated by VS and the .NET Core CLI
    private const string AspNetHttpsOid = "1.3.6.1.4.1.311.84.1.1";
    private const string AspNetHttpsOidFriendlyName = "ASP.NET Core HTTPS development certificate";

    public const string DefaultCertPemFileName = "cert.pem";
    public const string DefaultPrivateKeyFileName = "private.key";
    public const string DefaultCertPfxFileName = "cert.pfx";

    public static bool TryLoadCertificate(
        CommandLineOptions options,
        string currentDirectory,
        out X509Certificate2 cert,
        out Exception error)
    {
        cert = null;
        error = null;

        if (!options.UseTls)
        {
            return true;
        }

        try
        {
            cert = LoadCertificate(options, currentDirectory);
            if (!cert.HasPrivateKey)
            {
                throw new InvalidOperationException($"The certificate '{cert.SubjectName.Name} ({cert.Thumbprint})' is missing a private key.");
            }
            return true;
        }
        catch (Exception ex)
        {
            error = new InvalidOperationException($"Failed to configure the HTTPS. {ex.Message}", ex);
            return false;
        }
    }

    private static X509Certificate2 LoadCertificate(CommandLineOptions options, string currentDirectory)
    {
        if (!string.IsNullOrEmpty(options.CertPfxPath))
        {
            return LoadFromPfxFile(options.CertPfxPath, options.CertificatePassword);
        }

        if (!string.IsNullOrEmpty(options.CertPemPath))
        {
            var privateKeyPath = !string.IsNullOrEmpty(options.PrivateKeyPath)
                ? options.PrivateKeyPath
                : Path.Combine(Path.GetDirectoryName(options.CertPemPath), DefaultPrivateKeyFileName);
            return LoadFromPem(options.CertPemPath, privateKeyPath);
        }

        var defaultCertFile = Path.Combine(currentDirectory, DefaultCertPemFileName);
        var defaultKeyFile = Path.Combine(currentDirectory, DefaultPrivateKeyFileName);
        if (File.Exists(defaultCertFile) && File.Exists(defaultKeyFile))
        {
            return LoadFromPem(defaultCertFile, defaultKeyFile);
        }

        var defaultPfxFile = Path.Combine(currentDirectory, DefaultCertPfxFileName);
        if (File.Exists(defaultPfxFile))
        {
            return LoadFromPfxFile(defaultPfxFile, options.CertificatePassword);
        }

        if (options.ShouldUseLocalhost())
        {
            var retVal = LoadDeveloperCertificate();
            if (retVal != null)
            {
                return retVal;
            }
        }

        throw new InvalidOperationException("Could not find a certificate to use for HTTPS connections");
    }

    private static X509Certificate2 LoadFromPfxFile(string filepath, string password)
    {
        try
        {
            return new X509Certificate2(filepath, password);
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException($"Failed to load certificate file from '{filepath}' with error '{ex.Message}'.", ex);
        }
    }

    private static X509Certificate2 LoadFromPem(string certPath, string keyPath)
    {
        try
        {
            using var certWithoutPrivateKey = new X509Certificate2(certPath);
            using var keyFile = File.OpenText(keyPath);
            // Workaround https://github.com/dotnet/corefx/issues/20414
            var pemReader = new PemReader(keyFile);

            var pemObj = pemReader.ReadObject();
            switch (pemObj)
            {
                case RsaPrivateCrtKeyParameters rsaParams:
                    {
                        var rsa = rsaParams.ToRSA();
                        // See https://github.com/dotnet/corefx/issues/24454#issuecomment-388231655
                        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                        {
                            using var certWithKey = certWithoutPrivateKey.CopyWithPrivateKey(rsa);
                            return new X509Certificate2(certWithKey.Export(X509ContentType.Pkcs12));
                        }
                        else
                        {
                            // Only works on Linux/macOS
                            return certWithoutPrivateKey.CopyWithPrivateKey(rsa);
                        }
                    }
            }

            throw new InvalidOperationException($"Failed to read private key from '{keyPath}'. Unexpected format: " + pemObj.GetType().Name);
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException($"Failed to load certificate file from '{certPath}' and '{keyPath}'", ex);
        }
    }

    private static X509Certificate2 LoadDeveloperCertificate()
    {
        using var store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
        store.Open(OpenFlags.ReadOnly);
        var certs = store.Certificates.Find(X509FindType.FindByExtension, AspNetHttpsOid, validOnly: false);
        if (certs.Count == 1)
        {
            return certs[0];
        }

        if (certs.Count > 1)
        {
            // Returning a certificate which has the latest expiry date
            var expiryDate = DateTime.MinValue;
            var thumbprint = string.Empty;
            foreach (var certificate in certs)
            {
                if (certificate.NotAfter > expiryDate)
                {
                    expiryDate = certificate.NotAfter;
                    thumbprint = certificate.Thumbprint;
                }
            }
            return certs.Find(X509FindType.FindByThumbprint, thumbprint, validOnly: false)[0];
        }

        return null;
    }
}
